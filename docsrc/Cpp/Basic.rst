C++ 基础概念
=================

在配置了 C++ 的编译环境后（参考\ :doc:`Install`\ 一节），让我们编写第一个程序并了解 C++ 的一些基础内容。

Hello World
-----------------

我们的 Hello World 程序在\ :doc:`Install`\ 一节中已经提到过，这里来具体解释每一条语句含义。我们新建一个 `hello.cpp` 文件，并在其中填写以下内容：

.. literalinclude:: codes/hello/hello.cpp
    :linenos:
    :language: cpp

* **头文件**\ ：C++ 在文件的开头用 ``#include`` 预处理指令来包含头文件。上例中的 ``<iostream>`` 表示调用 C++ 标准库中的 iostream 库，该库提供了输入输出功能。
* **主函数**\ ：整个 C++ 项目中必须 *有且只有一个* 名为 ``main`` 的主函数，该主函数必须为整型（\ ``int`` 类型）。
  
  * 主函数可以不包含任何参数，比如上例中的 ``main()``\ 的圆括号内是空的，表示不接受任何参数。在后面我们会看到主函数接受参数的例子。
  * 主函数一般以返回 0 （例中 ``return 0``\ ）表示程序运行正常、返回非零值表示程序运行异常。

    .. hint::

       现代的 C++ 编译器不再强制要求在 main 函数的末尾书写 ``return 0;`` 语句（编译器会自动添加）。

  * 函数以一对花括号标记函数的开头与结尾。

* 输出：\ ``std::cout`` 表示调用 C++ 标准命名空间 ``std`` 中的 ``cout`` 对象，它代表标准输出； ``std::endl`` 代表行末，表示换行并打印已有的内容，它一般用在打印命令的结尾。
  
  * 标准命名空间 ``std`` 中包含了一系列 C++ 的变量与函数。命名空间的作用是防止名字发生重复，例如 ``cout`` 与 ``std::cout`` 就是两个不同的名字。但一般地，不建议使用命名空间中已有的名称来命名你自己的变量。
  * 输出运算符 ``<<`` 作用是将右侧的值写入到左侧的 ostream 对象，并返回左侧的对象。这一行语句表示将（用双引号包裹的）字符串 ``Hello world`` 写入到标准输出，然后执行打印。

.. attention::

    C++ 用英文分号表示一条语句的终止。你可以任意地把一条语句在空格位置分为多行；C++ 不关心语句中间的换行，它只关注分号所在的位置。

    注意 ``#include`` 是预处理指令而不是语句，它不能在中间换行，也不用分号结尾。

我们在当前文件夹打开 Powershell 命令行（如果你没有为 C++ 编译器配置 PATH 环境变量，那么使用 MSYS2 的 MINGW64 命令行）。我们调用安装的 GCC 编译器来编译 hello.cpp 源文件，并用 ``-o`` 指定输出可执行文件名为 hello：

.. code-block:: powershell

    g++ hello.cpp -o hello

以上命令会生成一个 hello.exe 文件。我们从命令行执行它：

.. code-block:: powershell

    ./hello

在命令行窗口中，我们可以看到它打印了字符串 Hello world。我们成功地运行了第一个 C++ 程序。


使用 CMake 编译*
--------------------

.. important::

    本小节是选读内容。关于 CMake 的安装，请参考\ :ref:`install-GCC-and-CMake`\ 一节。更多的 CMake 用法请参考\ :doc:`CMake`\ 一节或者 CMake 官方文档。

在上文中，我们直接使用了 GCC 命令来编译代码。在更复杂的项目中，我们需要包含多个头文件（hpp 文件）与源文件（cpp 文件）、处理外部库等，因此 CMake 是一个必须有所了解的编译工具。

我们仍然以 `hello.cpp`` 文件为例。这次，我们在它的旁边新建一个名为 `CMakeLists.txt` 的文件，用于配置 CMake 的编译：

.. literalinclude:: codes/hello/CMakeLists.txt
   :language: cmake

然后我们在当前文件夹下打开命令行，使用 CMake 命令来写入配置到 `build` 子文件夹，并编译生成可执行文件到文件夹内：

.. code-block:: powershell

    cmake -B build -DCMAKE_BUILD_TYPE Release
    cmake --build build

现在，我们可以运行可执行文件了。它的运行结果与通过上文的 GCC 命令编译的结果相同。

.. code-block:: powershell

    ./build/hello


.. _variable-declaration:

变量的声明与定义
-------------------

**变量**\ （Variable）是存储信息的基本具名单位。例如，我们用变量 ``apples`` 表示我们有几个苹果：

.. code-block:: cpp

    int apples;

上述语句用 ``int`` 关键字\ **声明**\ （Declare）了一个整数类型的变量，其名为 ``apples``\ 。

.. admonition:: C++ 中的命名规则
   :class: note

   用户自定义的名称统称为标识符。C++ 中的标识符遵循以下规则：
   
   * **大小写敏感**\ ，如 apples 与 Apples 是两个不同的标识符
   * 只能包含大写字母、小写字母、数字与下划线 ``_``
   * 只能以字母或者下划线开头
   * 不能与 C++ 关键字重名，如 int, double, auto 等
   * 不能与 C++ 操作符替代名重名，如 and, not, not_eq 等
   * 其他受限于标准库保留字的要求：
     
     * 不能有连续两个下划线
     * 不能以”下划线 + 大写字母“开头
     * 定义在函数体之外的变量，不能以下划线开头

.. important::

    对任意编程语言的一个变量名的实践准则是，尽量使用有意义的变量名。比如 ``apples`` 就比 ``n`` 要容易理解。

变量 ``apples`` 在声明后，还没有存储有意义的值。假设我们有 1 个苹果，将这个信息写入到该变量中：

.. code-block:: cpp

    apples = 1;

这里的等号表示“赋值”，即将赋值号右侧的值写入到左侧的变量。这里赋值号右侧的数字 1 是一个\ **字面值**\ （Literal），也就是数据的类型与值如字面所示的对象。例如，\ ``1`` 是一个整型字面值，而 ``"Hello world"`` 是一个字符串字面值。变量则相反，只阅读变量的字面名字，我们并不能看出变量的类型与存储的值。我们会在\ :doc:`DataTypes`\ 一节中更多地讨论不同数据类型的字面值。

-----

很显然，声明与初次赋值从逻辑上应当能整合为单次操作，即\ **定义**\ （Define）变量。我们可以简单地用一条变量定义语句来代替上述两条语句：

.. code-block:: cpp

    int apples = 1;

在定义时，我们用数字 1 对变量进行了\ **初始化**\ （Initialize）。变量定义实际上是一种特殊的声明，即带显式初始化的声明。

* 变量可以被\ *多次声明*\ （只要它们不冲突），但是只能被\ *定义一次*\ 。
* 在声明变量时，:uline:`如果该变量的类型能够进行默认初始化`\ ，C++ 就会自动用默认值对变量进行默认初始化。
* 初始化严格上并不等于声明加上初次赋值。后者实际上在声明时先执行了默认初始化，然后在赋值中用新数据替代了原有数据。
* 如果一个变量既没有成功被默认初始化，也没有被赋值，那么使用它会导致不可预料的后果（参考\ :ref:`undefined-behavior`\ 一节）。因此，\ **在能够手动地显式初始化时，总是手动地初始化变量**\ 。
* 使用等号进行初始化会自动进行类型转换（例如 ``int x = 1.2;``\ ）。用花括号则强制拒绝可能按引起精度损失的\ **窄化转换**\ （Narrowing conversion），例如从浮点数转换为整数 ``int x {1.2};`` 是不允许的。

最后，选择变量的数据类型也是重要的。本例中使用整型 ``int`` 来表示苹果的数量。但是，苹果不可能为负数，我们是否应该使用非负整型 ``unsigned int``\ ？如果苹果允许被切开，我们是否考虑使用带小数的类型，比如双精度浮点型 ``double``\ ？我们将在\ :doc:`DataTypes`\ 一节介绍变量的类型，以及常量（:ref:`const-and-constexpr` 一节）、类型别名（:ref:`type-aliases` 一节）等内容。


.. _function-basics:

函数
----------

**函数**\ （Function）是执行复杂任务最小单位。对于一个简单任务，我们通过一条语句就能完成，比如打印 `Hello world` 字符串。但一个复杂任务可能需要多条语句，并利用条件判断（参考 :ref:`if-statement`）、循环（参考 :ref:`for-loop`）等控制流结构。我们把这些语句放在一个函数中，以便反复使用它。以下是一个打印整数的函数示例：

.. literalinclude:: codes/function/function.cpp
   :linenos:
   :language: cpp

例中定义了一个打印函数 ``pretty_print``，它的类型是空 ``void``，表示不返回任何值。该函数接受一个名为 ``x`` 的整型 ``int`` **参数**\ （Argument）作为输入，并在函数内部利用这个传入的参数进行了打印操作。在主函数中，我们定义了两个整型变量，然后分别将它们用打印函数输出。在编译后，我们运行得到以下结果：

.. code-block:: console

    Int: 12
    Int: 34

.. hint::

    函数声明与定义的概念与变量类似。其具体用法是：
    
    * 如果它只包含返回类型、函数名、参数，那么它是一个函数声明语句（需要以分号结尾）。
    * 如果它除了包含返回类型、函数名、参数，还用花括号包含了函数体，那么它是一个函数定义。

    例如：

    .. code-block:: cpp

        // 函数声明
        int sum_square(int a, int b);

        // 函数定义
        int sum_square(int a, int b) {
            return a * a + b * b; 
        }
    
    在大型代码中，函数经常先在头文件中声明，之后再在源文件中定义（参见 :ref:`header-file` 一节）。在小型代码中，或者当函数的长度很短时，我们直接定义函数，而不分离声明与定义。

函数可以定义一个返回类型，以便利用返回的结果。例如，我们计算一个边长为整型的正方形的面积：

.. literalinclude:: codes/function/func_int.cpp
   :linenos:
   :language: cpp
   :emphasize-lines: 3, 9

以上将 ``square_area`` 函数的返回类型定义为整型 ``int``\ （因为我们知道边长为整数的正方形的面积也是整数），并将面积计算结果存放在主函数中的整型变量 ``area`` 中，然后打印出来。编译并运行得到结果：

.. code-block:: console

    Area = 9

显然，如果我们要根据半径计算圆的面积，函数的返回值就应当使用小数类型（例如 ``double``\ ）而不是整型。关于函数的更多内容（\ :doc:`Function`\ ），例如参数类型的隐式转换、函数重载、匿名函数，我们会在\ :doc:`DataTypes` 一节介绍数据类型之后再讨论。

.. admonition:: 一个函数应专注于一种任务

   定义函数的准则是：\ **让一个函数专注于完成一种任务**\ ，并用任务名为函数命名。例如，分别用两个独立的函数来定义正方形与圆的面积计算，总比定义一个“计算正方形或圆的面积”函数要好。
 
   .. code-block:: cpp

      // 建议的写法：每个函数完成单个任务
      double square_area(double square_size);
      double circle_area(double circle_radius);
    
      // 不建议的写法：函数与参数命名困难，代码逻辑糅合、难以阅读
      double square_or_circle_area(double shape_size);


.. _undefined-behavior:

未定义行为（UB）
--------------------

C++ 中的未定义行为（undefined behavior, UB）会导致不可预知的后果。程序可能继续工作，可能异常终止，也可能得到垃圾数据。例如，在数字运算中除以 0 就是一种典型的未定义行为。其他还有访问未初始化的变量、索引越界、对无效指针解引用等。

下例给出一个除以 0 的未定义行为例子：

.. literalinclude:: codes/ub/ub.cpp
   :linenos:
   :language: cpp 

上述代码可以编译通过并生成可执行文件。但是，可执行文件无法正常地运行或打印内容。
