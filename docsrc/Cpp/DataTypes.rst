常用数据类型
==============

本节介绍 C++ 的常见数据类型，包括：

* 基础数据类型：
  
  * 布尔型 `bool`\ ：参考 :ref:`bool-type` 一节
  * 整型（如 `int` 与 `char`）\ ：参考 :ref:`integral-type` 一节
  * 双精度浮点数 `double`\ ：参考 :ref:`floating-number` 一节

* 高级数据类型：
  
  * 基础数组 `[]`
  * std 字符串 `std::string`
  * std 数据类型，例如向量 `std::vector`\ 、映射 `std::map`\ 、数组 `std::array` 等，将在独立章节（:doc:`StdTypes`）中介绍

* 其他：
  
  * 空类型 `void`
  * 空指针类型 `nullptr`

.. hint::

    严格意义上说，以上并不全是“数据类型”。但本文在这一概念上不作纠缠。


.. _bool-type:

布尔型
------------

布尔型 `bool` 可能是最简单的类型，它只允许真 ``true`` 或者假 ``false`` 两种值。例如：

.. code-block:: cpp
    :linenos:

    bool has_cat = false;
    unsigned int cats = 0;
    
    ++cats;
    has_cat = true;

.. _bool-operator:

逻辑运算
^^^^^^^^^^^

布尔型对象可以使用与 ``&&``、或 ``||``、非 ``!`` 进行逻辑运算，并也能像数字运算那样用圆括号来分配优先级。

.. code-block:: cpp
    :linenos:

    bool x = false;
    bool y = true;

    bool r1 = x && y;  // false
    bool r2 = x || y;  // true
    bool r3 = !x;      // true

**C++ 的逻辑运算是短路的**\ 。如果当前的逻辑运算结果已经能确定表达式的值，那么就不会计算后续的表达式。例如， ``x && y && r1 && r2`` 会在检查到 `x` 为 `false` 时就立刻停止。利用这一特性，我们可以“防御”一些非法语句被执行。下面是一个利用逻辑短路而不会在除数为 0 时进行计算的例子：

.. code-block:: cpp
    :linenos:

    int x = 2;
    int y = 0;

    bool r = (y != 0) && (x / y > 0);


.. _integral-type:

整型：整数与字符
-------------------------

在 C++ 中，整数与字符型可以统称为整型（Integral type）。而在狭义上，我们用整型来称呼整数类型（Integer type）。

.. csv-table:: C++ 的常用基础整型数据类型
   :header: "关键字", "类型", "最小位数"
   :widths: 40, 30, 20
   :width: 75%
   :align: center
   
   char,字符,8
   signed char,有符号字符,8
   unsigned char,无符号字符,8
   (signed) short,有符号短整数,16
   unsigned short,无符号短整数,16
   int/signed/signed int,有符号整数,16
   (signed) long,有符号长整数,32
   unsigned long,无符号长整数,32
   (signed) long long |cpp11|,有符号长长整数,64
   unsigned long long |cpp11|,无符号长长整数,64

.. admonition:: char 的特殊性
   :class: warning

   在 C++ 中，`char` 是一种特殊的类型，因为它的无符号或者有符号取决于编译器的具体实现。`char` 并不是 `unsigned char` 或者 `signed char` 其中某一个的别名，它们三个是\ **三种不同的类型**\ 。在现代 C++ 中，`char` 类型至少会覆盖 ASCII 字符。


size_t 类型
^^^^^^^^^^^^^^^^^^^^^^^^^^

现代 C++ 还定义了一种 ``std::size_t`` |cpp11| 类型（可以由头文件 ``<cstddef>`` 引入），它表示程序中最大允许的对象尺寸。如果某种对象的尺寸超过了 size_t 的上限值，那么这个程序是错误的。size_t 被规定为无符号整数，且至少应该有 16 位。

size_t 常常被用作循环变量类型。不过由于它是无符号的，因此在反向循环时的写法与传统的 int 反向循环的写法不同，具体请参考 :ref:`reverse-loop` 一节。


整型字面值
^^^^^^^^^^^^^^^^^


关于宽字符与汉字*
^^^^^^^^^^^^^^^^^^

对于最常见的 UTF-8 编码，我们可以直接用字符型 ``char`` 来表示其数据。虽然每个 ``char`` 是单字节的，但是 ``std::string`` 类型（参见 :ref:`std-string` 一节）被设计为能够存储一系列 ``char`` 组成的多字节字符串。因此，我们可以直接使用 std::string 来存储汉字。

.. _operator-and-comparator:

运算符与比较符
----------------

C++ 正常地使用四则运算符来进行加减乘除运算，也允许用圆括号来表示运算的优先级。类似地，C++ 也用大于、小于等数学比较符（也称关系符）来比较对象；如果比较关系成立则返回逻辑真（\ ``true``\ ），否则返回逻辑假（\ ``false``\ ）。关于逻辑运算或布尔型变量，参考 :ref:`bool-type` 一节。

C++ 的运算符和比较符如下：

.. csv-table:: C++ 运算符与比较符
   :header: "运算符", "名称", "示例", "结果"
   :widths: 30, 30, 30, 20
   :width: 75%
   :align: center
   
   **二元运算符**,,,
   `+`, 加, ``4 + 2``, 6
   `-`, 减, ``4 - 2``, 2
   `*`, 乘, ``4 * 2``, 8
   `/`, 除, ``4 / 2``, 2
   `%`, （整型）取余, ``7 % 2``, 1
   **一元运算符**,,,
   `-`, 负, ``-3``, -3
   `++`, （整型）递增, ``int x=2; ++x;``, 3
   `--`, （整型）递减, ``int x=2; --x;``, 1
   **二元比较符**,,,
   `>` 或 `>=`, 大于（等于）, ``3 >= 2``, `true`
   `<` 或 `<=`, 小于（等于）, ``2 < 1``, `false`
   `==`, 等于, ``2 == 2``, `true`
   `!=`, 不等于, ``3 != 2``, `true`

位运算符将稍后在本节中介绍（见 :ref:`bitwise-operator` 一节）。逻辑运算符并未收录在本表中，具体请参考 :ref:`bool-operator` 一节。

.. admonition:: 关于递增与递减运算
   :class: tip

   递增与递减运算有两种写法。一种是作为前缀 ``++i``\ ，另一种是作为后缀 ``i++``\ 。通常来说，如果情况允许，我们更倾向于使用前缀运算的写法。

   两种写法的区别在于将该表达式用作语句的一部分时，变量的值是在递增（减）之后还是之前参与到语句中。前缀运算会先进行递增或递减运算，然后返回值；而后缀运算则相反。以下是一个例子：

   .. literalinclude:: codes/operator/incr-prefix-suffix.cpp
      :linenos:
      :language: cpp
   
   其输出为：

   .. code-block:: console
      
      i = 0
      a = 1
      i = 1
      b = 1
      i = 2

   这种微妙的差异将会影响循环语句中的循环变量递增（正向遍历）或递减（反向遍历）的写法，请参考 :ref:`for-loop` 一节。


运算中的类型转换
^^^^^^^^^^^^^^^^^^

在 C++ 中，两个整数之间的运算结果仍然是整数，例如整数间的除法将舍弃掉小数部分。如果是一个整数与一个浮点数计算除法，则结果自动转为浮点数。

要将两个整数间的除法结果保留成小数，需要利用 ``static_cast<double>``\ ，显式地将被除数或者除数转换为浮点数类型。例如：

.. literalinclude:: codes/operator/type-convert.cpp
   :linenos:
   :language: cpp
   :emphasize-lines: 10

以上输出结果：

.. code-block:: console
  
   Int = 1
   Double / Int = 1.66667
   Int / Double = 1.66667

现代 C++ 建议使用 ``static_cast<double>(x)`` 代替传统的 C 风格 ``(double)x`` 写法，因为前者有更好的类型安全性。


.. _bitwise-operator:

位运算符*
^^^^^^^^^^^

**位运算**\ （Bitwise operation）是一种特殊的运算，它使用对象的计算机的二进制位数据来进行计算。

* 按位与： ``&`` ，依次按位进行二元逻辑与计算（双方均为 1 则结果为 1，否则结果为 0）
* 按位或： ``|`` ，依次按位进行二元逻辑或计算（双方均为 0 则结果为 0，否则结果为 1）
* 按位异或： ``~`` ，依次按位进行二元逻辑或计算（双方不同则结果为 1，否则结果为 0）
* 取反： ``~`` ，对所有位进行一元逻辑非计算（1 则 0，0 则 1）
* 左移与右移： ``<<`` 与 ``>>`` ，将所有的位向左或右移动若干位。左移时低位补 0，右移时高位补 0。

下面是上述位运算符的使用示例：

.. literalinclude:: codes/operator/bitwise.cpp
   :linenos:
   :language: cpp

我们得到：

.. code-block:: console
   
   x = 9, y = 5
   Bitwise AND: x & y = 1
   Bitwise OR : x | y = 13
   Bitwise XOR: x ^ y = 12
   Bitwise NOT: ~x = -10
   Left-shift : x << 1 = 18
   Right-shift: x >> 2 = 2

.. admonition:: 如何理解取反（`~`）的运算结果？
   :class: note
   
   要理解为什么 `9` （二进制 1001）的取反结果是 `-10`\ （而不是二进制 0110 即 6），我们必须了解计算机中的带符号整型是如何按二进制存储的。
   
   带符号整型的最高位为 0 时，表示存储正数；为 1 时，表示存储负数。以一个 8 位的整型类型为例，该类型一共能存储 :math:`2^8 = 256` 种数字。一般来说，其范围是从 -128 到 127 的每个整数。最高位为 0、后续位全为 1 的数（\ `0111 1111`\ ）表示该类型能存储的最大数，即 127。如果不考虑溢出，再尝试加 1时，会进位并改变最高位为 1，得到 `1000 0000`\ ，这也就是该类型能存储的最小数，即 -128。

   对于正二进制数，我们很容易将二进制数转为十进制，例如 `0000 0101` 就可以由按位累加 2 的幂得到 :math:`1\times 2^0 + 0\times 2^1 + 1\times 2^2 = 5`\ ，即 5。对于负二进制数，我们注意到 `1000 0000` 表示 -128；而 `1111 1111` 表示 0 之前的那个数，即 -1。那么，我们根据线性对应关系，可知\ :uline:`将负二进制数转为十进制的步骤是：先取反得到正二进制数，将该数字转为十进制，再加上 1，最后添加负号`\ 。

   例如，对于数字 9，其二进制表示中的低四位是 1001，再往上的高位全部是 0。现在以 8 位为例，即 `0000 1001`\ 。我们对它进行取反操作，得到 `1111 0110`\ 。由于最高位是 1，这是一个负二进制数。要将这个取反后的结果转为十进制，我们先将它取反转为十进制（重新得到 9）、再加 1（得到 10），最后添加符号（得到 -10）。因此，数字 9 的按位取反后会得到 -10。


.. _floating-number:

浮点数
-------------



.. _string:

字符串
-------------


.. _std-string:

std 字符串
^^^^^^^^^^^^^^^^

.. _const-and-constexpr:

常量与常量表达式
-----------------------------

.. _type-aliases:

类型别名与推断
-----------------

C++ 中大致有以下类型别名和推断方法：

* 别名：using（以及 typedef）
* 推断：auto 或 decltype

using 类型别名
^^^^^^^^^^^^^^^^^^^

``using`` 关键字在 C++ 中历史悠久，但提供类型别名 |cpp11| 的功能是从 C++ 11 开始的。以下是一个例子：

.. code-block:: cpp
   :linenos:

   using ages = int;     // 将 ages 定义为 int 的别名
   ages person_age = 24;

.. hint::

   C++ 还提供了 ``typedef`` 来自定义类型名，用法如 ``typedef int ages;`` 但这里不再推荐这种用法。由于 `using` 完全覆盖了 `typedef` 的使用情景，并且还能用在一些后者无法使用的地方（比如模板别名），因此建议总是使用 `using`\ 。


auto 关键字
^^^^^^^^^^^^^^^^

现代 C++ 允许使用 ``auto`` |cpp11| 来在变量定义时自动推断类型。例如，``2`` 是 `int` 类型， ``2.718`` 是 `double` 类型：

.. code-block:: cpp
   :linenos:

   auto x = 2;        // int
   auto y = 2.718;    // double
   auto z = x + y;    // double
   auto s = "Hello";  // const char*

在一般的场合，我们应当在定义时直接写出类型全名来提供较好的可读性，也避免推断的类型不符合预期。例如，我们可能希望上例中的字符串变量类型为 ``std::string`` 而不是 ``cosnt char*``\ 。

auto 的一种使用场合是在类型全名太长时，这时反而使用 auto 会获得更好的可读性。另一种常用的情况是要定义的变量类型是显然的（或者不重要的），例如在 for 循环中使用 auto 来定义循环变量。 

decltype*
^^^^^^^^^^^^^

现代 C++ 允许使用 ``decltype`` 来“借用”已有对象的类型。比较特殊的是，它会保留引用类型以及顶层常量属性。

.. code-block:: cpp
   :linenos:

   const int m = 12, &r = m;
   decltype(n) n1 = 0;     // 推断为 const int
   decltype(r) r1 = m;     // 推断为 const int& 引用
   
   int n = 37, *p = &n;
   decltype(*p) r2 = n;    // 解引用后，推断为 int& 引用
