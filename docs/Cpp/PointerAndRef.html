

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>引用与指针 &mdash; Cpp  文档</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="_static/style.css?v=3491b469" />

  
    <link rel="canonical" href="https://self-contained.github.io/Cpp/PointerAndRef.html"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=7d86a446"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="_static/copybutton.js?v=f281be69"></script>
      <script src="_static/translations.js?v=beaddf03"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="控制流语句" href="Control.html" />
    <link rel="prev" title="类型转换与溢出*" href="TypeConversion.html" />
 

<!-- <link rel="stylesheet" type="text/css" href="_config/static/DataTables/datatables.min.css"/> -->

<meta name="google-site-verification" content="ZsXR1o8suFFOr_MSgo5BTvjbznAuEP6XYOmgMiBu5Yw" />
<script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-90643174-3']);
  _gaq.push(['_trackPageview']);
</script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >


          
          
          <a href="index.html" class="icon icon-home">
            Cpp
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
<div class="home-button">
   <a class="home-button" href="https://github.com/wklchris/blog">
      仓库
   </a>&nbsp;&nbsp;|&nbsp;&nbsp;<a class="home-button" href="/blog/">
      博客主页
   </a>&nbsp;&nbsp;|&nbsp;&nbsp;<a class="home-button" href="/">
      关于我
   </a>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="QuickRef.html">速查：C++ 语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Install.html">安装 C++ 环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="Intro.html">C++ 简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="Variables.html">变量基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataTypes.html">常用数据类型</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataTypesAdvance.html">数据类型进阶</a></li>
<li class="toctree-l1"><a class="reference internal" href="TypeConversion.html">类型转换与溢出*</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">引用与指针</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#reference">引用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#const-reference">常量引用</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pointer">基础指针</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">指针的布尔操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">指针嵌套</a></li>
<li class="toctree-l3"><a class="reference internal" href="#const">指针与 const</a></li>
<li class="toctree-l3"><a class="reference internal" href="#void">void 指针*</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#smart-pointer">智能指针</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#shared-ptr">共享指针：shared_ptr</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unique-ptr">独占指针：unique_ptr</a></li>
<li class="toctree-l3"><a class="reference internal" href="#weak-ptr">弱指针：weak_ptr</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Control.html">控制流语句</a></li>
<li class="toctree-l1"><a class="reference internal" href="CMake.html">附录1：CMake 工具</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Cpp</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">引用与指针</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/PointerAndRef.rst.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="caution admonition">
<p class="admonition-title">施工提示</p>
<p>本博文尚在施工中，内容并未完成且可能变更。</p>
</div>
<section id="id1">
<h1>引用与指针<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<p>C++ 中的引用（reference）与指针（pointer）可能是最令人头痛的内容。</p>
<section id="reference">
<span id="id2"></span><h2>引用<a class="headerlink" href="#reference" title="Link to this heading"></a></h2>
<p>在定义引用时，使用 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 符作为标识符前缀：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">     </span><span class="c1">// 定义一个 n 的引用，其名为 r</span>
</pre></div>
</div>
<p>引用在定义时不会拷贝值，而是与被引用对象进行绑定。</p>
<ul>
<li><p>引用本身不是对象</p></li>
<li><p>引用在定义时必须初始化，且其初始绑定必须是一个 <strong>同类型对象</strong>。除了两种例外：</p>
<ul class="simple">
<li><p>定义对常量的引用时，也允许使用任意 <em>能转换为该类型</em> 的表达式，甚至字面值。参考 <a class="reference internal" href="#const-reference"><span class="std std-ref">常量引用</span></a> 一节。</p></li>
<li><p>在基类中定义引用时，也允许绑定到派生类对象</p></li>
</ul>
</li>
<li><p>引用在定义后，不能更改绑定到新的对象</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14159</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="c1">// 以下均错误</span>
<span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">255</span><span class="p">;</span><span class="w">  </span><span class="c1">// 错误：不能引用字面值</span>
<span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">    </span><span class="c1">// 错误：不能引用一个引用</span>
<span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi</span><span class="p">;</span><span class="w">   </span><span class="c1">// 错误：对象非 int 类型</span>
<span class="o">&amp;</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w">         </span><span class="c1">// 错误：&amp;r 不是左值（不能改变绑定到新的对象）</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>再次重申：引用不是对象，它只是被引对象的另一个名字。</p>
</div>
<p>通过引用，我们可以修改原对象的值（除了对 const 常量的引用情形，参考 <a class="reference internal" href="#const-reference"><span class="std std-ref">常量引用</span></a> 一节）：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// val 的值变为 3</span>
</pre></div>
</div>
<section id="const-reference">
<span id="id3"></span><h3>常量引用<a class="headerlink" href="#const-reference" title="Link to this heading"></a></h3>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>常量引用与普通的引用有诸多不同之处，这有助于我们更深入地理解引用。</p>
</div>
<p>有时我们称呼“对 const 常量的引用”为“常量引用”，因为这样更简单。由于引用不是对象，常量是修饰被引用对象的（而不是修饰引用名），因此这两种表述实质等同，不涉及歧义。与之不同的是，“指针常量”与“指向常量的指针”则表示的是不同的东西。</p>
<p>常量引用不允许对绑定对象进行修改：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cval</span><span class="p">;</span>
<span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w">     </span><span class="c1">// 错误：不允许修改对常量的引用</span>
</pre></div>
</div>
<p>此外，常量引用的特殊之处在于，允许使用任意同类型（或能转换为该类型的）表达式作为初始值。而普通引用不允许转换类型，也不允许使用字面值。下例给出了一些正确的常量引用定义：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.23</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">127</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>为什么上述定义对于常量引用是允许的，对于普通的引用就不允许？这是因为上述语句在定义时实际上借助了临时量：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w">     </span><span class="c1">// 先用临时量对 val 进行类型转换</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w">     </span><span class="c1">// 再将 r1 绑定到临时量 temp 上</span>
</pre></div>
</div>
<p>同理，常量引用 <code class="docutils literal notranslate"><span class="pre">&amp;r2</span></code> 在定义时，也需要对字面值创建临时量。毕竟引用的定义实质上就是对某个对象的绑定。</p>
<p>在常量引用中，由于绑定值不可修改，因此上述定义是允许的。如果非常量引用可以这样定义，那么会导致修改引用实质上修改了临时量的值，而不是原始对象的值；这种逻辑是不合理的，因此不允许这样定义非常量引用。</p>
</div>
</section>
</section>
<section id="pointer">
<span id="id4"></span><h2>基础指针<a class="headerlink" href="#pointer" title="Link to this heading"></a></h2>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>下面你将认识的是，C++ 世界中最强大的苦痛之源、声名远播到甚至其他编程语言世界的折磨王，指针。请打起精神！</p>
</div>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>为了更安全地管理动态内存，现代 C++ 提倡使用智能指针，参考 <a class="reference internal" href="#smart-pointer"><span class="std std-ref">智能指针</span></a>。在阅读智能指针相关的内容前，我仍推荐阅读本节了解基础的指针概念。</p>
</div>
<p>指针像引用一样提供了对其他对象的访问。但不同的是：</p>
<ul>
<li><p>指针本身是一个对象。指针可以被复制，也可以被更改指向的对象。</p></li>
<li><p>指针实质上存储了所指向对象的地址。</p></li>
<li><p>在语法上，指针在定义时可以不显式地指定其初始值。</p>
<ul class="simple">
<li><p>建议总是显式初始化指针，至少指向空指针字面值 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code><span class="cpp hlblue xsmall">C++ 11</span>。在过去，空指针使用 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或者 0，现在应当使用 nullptr 代替。</p></li>
</ul>
<div class="admonition danger">
<p class="admonition-title">危险</p>
<p>警惕对无效指针进行操作，这会导致错误。更进一步地，应该在代码中尽可能地消除无效指针的出现。</p>
</div>
</li>
</ul>
<p>在定义指针时，使用 <code class="docutils literal notranslate"><span class="pre">*</span></code> 标识符前缀：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 定义整数 m, n 以及一个指向整数的指针 p1</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="c1">// 定义一个空指针 p2</span>
<span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// 定义一个指针 p3, 初始化为指针 p1 指向的对象（p1 中存放的地址）</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 注意，此时不需要用 &amp; 对 p1 取地址</span>
</pre></div>
</div>
<div class="admonition-int-p-int-p admonition">
<p class="admonition-title">建议使用 int *p 而不是 int* p</p>
<p>有时候我们会看见用 <code class="docutils literal notranslate"><span class="pre">int*</span> <span class="pre">p;</span></code> 这种书写方式表示定义 int 指针的写法。它把 int 与 * 写在一起，强调我们正在定义的是一个指针，而不是一个简单的 int 类型变量。</p>
<p>我并不推荐这种写法。在定义时， <code class="docutils literal notranslate"><span class="pre">*p</span></code> 应当视为一个整体（变量标识符），表示要定义一个指针，其名为 p。写为 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*p</span></code> 可以较少地引起误解。这也可以通过下例说明：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 等价于：int *p1, p2, p3;</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">;</span><span class="w">    </span><span class="c1">// 定义了一个指针 p1 与两个整数 p2, p3</span>
</pre></div>
</div>
<p>即使写成 <code class="docutils literal notranslate"><span class="pre">int*</span></code>，它们也不能视为一个整体，故也不能认为 p2, p3 被定义为指针。因此，我认为 <code class="docutils literal notranslate"><span class="pre">int*</span></code> 这种迷惑性的写法是应当避免的。</p>
</div>
<p>下面是一个简单的例子，展示了指针的基本操作：</p>
<ul class="simple">
<li><p>指针需要指向一个同类型对象，并利用 <strong>取地址符（</strong><code class="docutils literal notranslate"><span class="pre">&amp;</span></code><strong>）</strong> 取得对象的地址。</p></li>
<li><p>在使用指针时，利用 <strong>解引用符（</strong><code class="docutils literal notranslate"><span class="pre">*</span></code><strong>）</strong> 访问指向的对象。</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="linenos"> 2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="linenos"> 3</span><span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.23</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;*p = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span>
<span class="linenos">10</span><span class="w">         </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">p = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w">    </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.3</span><span class="p">;</span>
<span class="linenos">13</span><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">*p = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span>
<span class="linenos">14</span><span class="w">         </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">x = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">15</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">16</span><span class="p">}</span>
<span class="linenos">17</span><span class="cm">/*</span>
<span class="linenos">18</span><span class="cm">  输出（p 的地址每次运行都会不同）：</span>
<span class="linenos">19</span><span class="cm">  *p = 1.23</span>
<span class="linenos">20</span><span class="cm">  p = 0xac89bffc70</span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="cm">  *p = 0.3</span>
<span class="linenos">23</span><span class="cm">  x = 0.3</span>
<span class="linenos">24</span><span class="cm">*/</span>
</pre></div>
</div>
<p>在使用指针时，一定不要混淆这两种用法：</p>
<ul class="simple">
<li><p>对解引用的指针 <code class="docutils literal notranslate"><span class="pre">*p</span></code> 进行赋值，等于对指针 <code class="docutils literal notranslate"><span class="pre">p</span></code> 指向的对象赋值，指针仍然指向那个对象。</p></li>
<li><p>对指针 <code class="docutils literal notranslate"><span class="pre">p</span></code> 进行赋值，等于更改指针 <code class="docutils literal notranslate"><span class="pre">p</span></code> 中存放的地址，即指针指向了一个新的对象。</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">9.80665</span><span class="p">;</span>
<span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// 更改 x 为 2.0，指针 p 仍指向 x</span>
<span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="c1">// 让指针 p 指向新对象 y</span>
<span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
<section id="id5">
<h3>指针的布尔操作<a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>当一个指针是空指针时，其逻辑值为 false；否则为 true。</p></li>
<li><p>如果两个指针均为空指针，或者它们存储了相同地址，那么这两个指针相等；否则它们不相等。</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="linenos"> 2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="linenos"> 3</span><span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="linenos">10</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;p: false&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span>
<span class="linenos">13</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;p1 == p2&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">14</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="linenos">15</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;p == q&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">16</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">17</span><span class="p">}</span>
<span class="linenos">18</span><span class="cm">/*</span>
<span class="linenos">19</span><span class="cm">  输出：</span>
<span class="linenos">20</span><span class="cm">  p: false</span>
<span class="linenos">21</span><span class="cm">  p1 == p2</span>
<span class="linenos">22</span><span class="cm">  p == q</span>
<span class="linenos">23</span><span class="cm">*/</span>
</pre></div>
</div>
</section>
<section id="id6">
<h3>指针嵌套<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<p>由于指针是对象，因此指针与引用也都可以指向一个指针对象。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="c1">// p 是一个指向 int 变量 n 的指针</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>
<span class="c1">// q 是一个指向 int 型指针 p 的指针</span>
<span class="c1">// 要解引用到 n，使用 **q</span>
<span class="kt">int</span><span class="w"> </span><span class="o">**</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>

<span class="c1">// r 是对指针 p 的引用</span>
<span class="c1">// 要解引用，使用 *r</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
</pre></div>
</div>
<p>对指针的引用 <code class="docutils literal notranslate"><span class="pre">*&amp;r</span></code> 可以从右往左理解：我们要定义的是 <code class="docutils literal notranslate"><span class="pre">r</span></code>，它是一个引用（<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>），这个引用将引用一个指针对象（<code class="docutils literal notranslate"><span class="pre">*</span></code>），而这个指针应是 int 类型的。</p>
</section>
<section id="const">
<span id="pointer-and-const"></span><h3>指针与 const<a class="headerlink" href="#const" title="Link to this heading"></a></h3>
<p>指针与 const 有两种组合方式：一是指向常量的指针，二是常量指针。</p>
<p><strong>指向常量的指针</strong>，比如 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">*p</span></code>，就像常量引用一样，不能通过它改变指向对象的值。</p>
<ul>
<li><p>如果要让指针指向一个常量，只能使用指向常量的指针，不能使用常量指针或普通指针。</p></li>
<li><p>指向常量的指针只是不允许通过该指针更改其指向对象，但指向对象可以是非常量对象。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span>
<span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14159</span><span class="p">;</span><span class="w">      </span><span class="c1">// 错误：不能更改 p 指向的对象</span>
</pre></div>
</div>
</li>
</ul>
<p><strong>常量指针</strong>，比如 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*const</span> <span class="pre">p</span></code>，是指指针本身是常量（而不是说指针指向的对象是常量）。</p>
<ul>
<li><p>常量指针必须显式初始化。</p></li>
<li><p>常量指针的值（即其存放的地址）一经初始化，就不能改变。</p></li>
<li><p>与前述的指向常量的指针组合，可以得到指向常量的常量指针（<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">*const</span> <span class="pre">p</span></code>）</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 常量指针 q1，指向整数 m</span>
<span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">14</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">q1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">;</span>

<span class="c1">// 指向常量的常量指针 q2，指向 int 型常量 n</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">q2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
<p>同样从右往左理解 q2 的定义：我们要定义的是 <code class="docutils literal notranslate"><span class="pre">q2</span></code>；它是一个常量（<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>），还是一个指针（<code class="docutils literal notranslate"><span class="pre">*</span></code>），也就是说它是一个常量指针；这个常量指针将指向一个 int 型常量（<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span></code>），也就是说它同时是一个指向常量的指针。</p>
<div class="note admonition">
<p class="admonition-title">顶层常量与底层常量</p>
<p>像上例中展示的一样，指针的特殊性使得 const 的修饰有时让人迷惑。如果指针本身是一个常量，我们称之为 <strong>顶层常量</strong>，比如常量指针；如果指针的基础类型（指向对象的类型）是一个常量，我们称之为 <strong>底层常量</strong>，比如指向常量的指针。在一个多重 const 修饰的定义中：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">q2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>
</pre></div>
</div>
<p>第一个 const 表示指向的是一个 int 型常量，因此它对应底层常量；第二个 const 表示要定义的是一个 const 类型的指针，因此它对应顶层常量。</p>
<ul class="simple">
<li><p>顶层常量可以复制到同类型的非常量。</p></li>
<li><p>底层常量在复制时，要求两个对象具有相同的底层常量类型，或者可以转换。一般非常量可以转换为常量，反之不允许。</p></li>
</ul>
</div>
</section>
<section id="void">
<span id="void-pointer"></span><h3>void 指针*<a class="headerlink" href="#void" title="Link to this heading"></a></h3>
<p>void 指针是一种特殊指针，它可以存放任意对象的地址。它可以用于不清楚所指对象类型的场合，但是局限性很大。它只能：</p>
<ul class="simple">
<li><p>指向任意对象的地址</p></li>
<li><p>进行布尔操作</p></li>
<li><p>作为函数输入或输出</p></li>
<li><p>赋给另一个 void 指针</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.2</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>
</pre></div>
</div>
<p>由于不能通过 void 指针更改其指向的对象，我们较少使用这种指针。</p>
</section>
</section>
<section id="smart-pointer">
<span id="id7"></span><h2>智能指针<a class="headerlink" href="#smart-pointer" title="Link to this heading"></a></h2>
<p>智能指针 <span class="cpp hlblue xsmall">C++ 11</span> 模板由标准库 <code class="docutils literal notranslate"><span class="pre">&lt;memory&gt;</span></code> 提供，旨在结束指针的所有使用后自动销毁指向的对象，从而释放内存。该库提供了两种智能指针：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::shared_ptr&lt;T&gt;</span></code> 声明一个共享智能指针。允许与其他指针共享其所指向的、类型为 T 的对象。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;T&gt;</span></code> 声明一个独占智能指针。不允许其他指针指向其所指的、类型为 T 的对象。</p></li>
</ul>
<p>以及一种比较特殊的弱指针 <code class="docutils literal notranslate"><span class="pre">std::weak_ptr&lt;T&gt;</span></code>。</p>
<section id="shared-ptr">
<h3>共享指针：shared_ptr<a class="headerlink" href="#shared-ptr" title="Link to this heading"></a></h3>
<p>为 <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> 分配动态内存时，推荐使用 <code class="docutils literal notranslate"><span class="pre">std::make_shared&lt;T&gt;</span></code> 函数，它将在动态内存中分配一个类型为 T 的对象（并用函数接受的参数初始化 T 对象），然后返回一个指向该对象的 <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> 指针。给该函数传递参数时，参数的形式必须与 T 类型的某一构造函数匹配。</p>
<p>一个使用 <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> 智能指针的用例：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::make_shared</span></code>：分配动态内存，常用于初始化智能指针。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sp1.swap(sp2)</span></code>：交换两个智能指针 sp1 与 sp2 的值。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sp.reset()</span></code>：让 sp 不再指向原对象。如果无其他共享指针指向该对象，则释放该对象。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sp.unique()</span></code>：检查 sp 是否是所指对象的唯一用户。</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="linenos"> 2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 5</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="c1">// 使用 auto 简化书写</span>
<span class="linenos"> 7</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">sp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">37</span><span class="p">);</span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="c1">// swap: 交换两个智能指针的值</span>
<span class="linenos">10</span><span class="w">    </span><span class="n">sp2</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="linenos">11</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;sp: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, sp2: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">sp2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="w">    </span><span class="c1">// 令 sp 指向 sp2 指向的对象</span>
<span class="linenos">14</span><span class="w">    </span><span class="c1">// 当 sp 原指向的对象没有任何智能指针引用时，其会被销毁</span>
<span class="linenos">15</span><span class="w">    </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp2</span><span class="p">;</span>
<span class="linenos">16</span>
<span class="linenos">17</span><span class="w">    </span><span class="c1">// 拷贝智能指针，让 sp3 指向与 sp2 相同的对象</span>
<span class="linenos">18</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">sp3</span><span class="p">(</span><span class="n">sp2</span><span class="p">);</span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="w">    </span><span class="c1">// unique(): 检查 sp 是否是所指对象的唯一用户</span>
<span class="linenos">21</span><span class="w">    </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
<span class="linenos">22</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;sp unique? &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sp</span><span class="p">.</span><span class="n">unique</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">23</span><span class="w">    </span>
<span class="linenos">24</span><span class="w">    </span><span class="c1">// reset: 让 sp 不再指向任何对象。如果无其他共享指针指向该对象，则释放其内存</span>
<span class="linenos">25</span><span class="w">    </span><span class="n">sp</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="linenos">26</span><span class="p">}</span>
<span class="linenos">27</span><span class="cm">/*</span>
<span class="linenos">28</span><span class="cm">  输出：</span>
<span class="linenos">29</span><span class="cm">  sp: 37, sp2: 12</span>
<span class="linenos">30</span><span class="cm">  sp unique? 1</span>
<span class="linenos">31</span><span class="cm">*/</span>
</pre></div>
</div>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> 通过引用计数器来控制销毁。当初始化或拷贝智能指针时，计数器会加1；当智能指针被赋予一个新值（令其指向一个新对象），或者离开作用域时，计数器会减1。当计数器归零时，其指向的对象会被释放。</p>
<ul class="simple">
<li><p>如果将在临时容器内存储 <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>（比如用于排序），那么在使用后应当用 erase 或者 clear 释放容器以便销毁。</p></li>
</ul>
</li>
<li><p>类对象有时需要在内部使用其自身的共享指针。这时，我们需要让类继承 <code class="docutils literal notranslate"><span class="pre">std::enable_shared_from_this&lt;ClassName&gt;</span></code> 并使用 <code class="docutils literal notranslate"><span class="pre">shared_from_this()</span></code>：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// ...</span>
<span class="w">   </span><span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared_from_this</span><span class="p">();</span>
<span class="w">   </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>具体的使用，请参考 <a class="reference internal" href="#pointer-smart-weak-treenode"><span class="std std-ref">智能指针示例：树节点</span></a> 的代码。</p>
</li>
</ul>
</section>
<section id="unique-ptr">
<h3>独占指针：unique_ptr<a class="headerlink" href="#unique-ptr" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> 并不能像 <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> 一样使用 <code class="docutils literal notranslate"><span class="pre">make_shared</span></code> 分配动态内存，而是使用 <code class="docutils literal notranslate"><span class="pre">make_unique</span></code><span class="cpp hlblue xsmall">C++ 14</span> 代替。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="linenos"> 2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="k">class</span><span class="w"> </span><span class="nc">DataClass</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 5</span><span class="k">private</span><span class="o">:</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="linenos"> 9</span><span class="k">public</span><span class="o">:</span>
<span class="linenos">10</span><span class="w">    </span><span class="n">DataClass</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="linenos">11</span><span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="nf">getResult</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="linenos">12</span><span class="p">};</span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">15</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">up1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
<span class="linenos">16</span><span class="w">    </span><span class="c1">// 使用 auto 简化书写</span>
<span class="linenos">17</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">up2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">79</span><span class="p">);</span>
<span class="linenos">18</span><span class="w">    </span><span class="c1">// 交换两个指针的值</span>
<span class="linenos">19</span><span class="w">    </span><span class="n">up2</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">up1</span><span class="p">);</span>
<span class="linenos">20</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;up1: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">up1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, up2: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">up2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">21</span><span class="w">    </span><span class="c1">// 传入符合 DataClass 构造函数的参数</span>
<span class="linenos">22</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">up3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">DataClass</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="p">);</span>
<span class="linenos">23</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Result: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">up3</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">24</span><span class="p">}</span>
<span class="linenos">25</span><span class="cm">/*</span>
<span class="linenos">26</span><span class="cm">  输出：</span>
<span class="linenos">27</span><span class="cm">  up1: 79, up2: 12</span>
<span class="linenos">28</span><span class="cm">  Result: 6.28</span>
<span class="linenos">29</span><span class="cm">*/</span>
</pre></div>
</div>
<p>独占指针也可以使用 <code class="docutils literal notranslate"><span class="pre">up1.swap(up2)</span></code> 来交换两个指针的值。</p>
</section>
<section id="weak-ptr">
<h3>弱指针：weak_ptr<a class="headerlink" href="#weak-ptr" title="Link to this heading"></a></h3>
<p>弱指针 <code class="docutils literal notranslate"><span class="pre">std::weak_ptr</span></code> 是一种有趣而实用的指针，它可以指向一个共享指针 <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> 指向的对象，但不影响其引用计数器。当最后一个指向该对象的共享指针销毁，即使仍然有弱指针指向它，该对象也会被释放。</p>
<ul class="simple">
<li><p>弱指针需要使用共享指针来初始化。</p></li>
<li><p>弱指针可能指向无效，因此必须在使用时用其 <code class="docutils literal notranslate"><span class="pre">.lock()/.expired()</span></code> 成员函数来检查。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">expired()</span></code>：判断弱指针是否有效（指向的对象是否被释放），返回 true 或者 false。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lock()</span></code>：当弱指针有效时，返回一个指向对象的共享指针；否则，返回一个空的共享指针。</p></li>
</ul>
</li>
</ul>
<div class="note admonition">
<p class="admonition-title">将弱指针临时强化为共享指针，再访问其指向的对象</p>
<p>对于弱指针 wp，一般我们先用 <code class="docutils literal notranslate"><span class="pre">sp</span> <span class="pre">=</span> <span class="pre">wp.lock()</span></code> 返回共享指针对象 <code class="docutils literal notranslate"><span class="pre">sp</span></code>，并用 if 语句判断其是否为空。如果非空，那么我们可以操作这个临时的共享指针，例如 <code class="docutils literal notranslate"><span class="pre">sp-&gt;member()</span></code>。</p>
</div>
<p>下例展示了弱指针的一些基本用法：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="linenos"> 2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="kt">void</span><span class="w"> </span><span class="nf">wp_check</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_weak</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 5</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_weak</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">        </span><span class="c1">// p_weak 指向的对象有效</span>
<span class="linenos"> 7</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Valid: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Invalid weak pointer.&quot;</span><span class="p">;</span>
<span class="linenos">10</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">11</span><span class="p">}</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">14</span><span class="w">    </span><span class="c1">// 用共享指针 sp 初始化弱指针 wp</span>
<span class="linenos">15</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="linenos">16</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">wp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="linenos">17</span><span class="w">    </span><span class="n">wp_check</span><span class="p">(</span><span class="n">wp</span><span class="p">);</span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="w">    </span><span class="c1">// 将 sp 置空，其指向对象被释放</span>
<span class="linenos">20</span><span class="w">    </span><span class="n">sp</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w">  </span>
<span class="linenos">21</span><span class="w">    </span><span class="n">wp_check</span><span class="p">(</span><span class="n">wp</span><span class="p">);</span>
<span class="linenos">22</span>
<span class="linenos">23</span><span class="w">    </span><span class="c1">// 将 wp 置空</span>
<span class="linenos">24</span><span class="w">    </span><span class="n">wp</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w">  </span>
<span class="linenos">25</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">26</span><span class="p">}</span>
<span class="linenos">27</span><span class="cm">/*</span>
<span class="linenos">28</span><span class="cm">  输出：</span>
<span class="linenos">29</span><span class="cm">  Valid: 7</span>
<span class="linenos">30</span><span class="cm">  Invalid weak pointer.</span>
<span class="linenos">31</span><span class="cm">*/</span>
</pre></div>
</div>
<p>弱指针的一个重要意义是在 <strong>设计从属关系的对象时避免循环引用</strong>（因为这会阻止智能指针释放对象）。例如，在树的节点定义中，父节点需要一系列指针指向其每个子节点，而子节点也需要一个指针指向其父节点。如果在这两处都使用共享指针，那么父节点与子节点将会相互指向，导致节点在被删除时引用计数总不为零，从而并不能被释放。因此，我们在节点中使用共享指针定义 <code class="docutils literal notranslate"><span class="pre">children</span></code>，使用弱指针定义 <code class="docutils literal notranslate"><span class="pre">parent</span></code>。</p>
<p>下例是一个使用弱指针与共享指针，对树节点进行定义的例子：</p>
<div class="highlight-c++ notranslate" id="pointer-smart-weak-treenode"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span>
<span class="linenos"> 2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="linenos"> 3</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>
<span class="linenos"> 4</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="k">public</span><span class="o">:</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="n">Node</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{};</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">addChild</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">child</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">10</span><span class="w">        </span><span class="c1">// 使用 shared_from_this 从对象内部创建其自身的共享指针</span>
<span class="linenos">11</span><span class="w">        </span><span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared_from_this</span><span class="p">();</span>
<span class="linenos">12</span><span class="w">        </span><span class="n">children</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="linenos">13</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">14</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">removeChild</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">child</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 传引用，以更改外部 child</span>
<span class="linenos">15</span><span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">children</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">children</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
<span class="linenos">16</span><span class="w">                               </span><span class="p">[</span><span class="o">&amp;</span><span class="n">child</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">child</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="linenos">17</span><span class="w">        </span><span class="c1">// 将 child 从当前节点的子节点列表中移除，然后置空 child</span>
<span class="linenos">18</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">children</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">19</span><span class="w">            </span><span class="n">children</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
<span class="linenos">20</span><span class="w">            </span><span class="n">child</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="linenos">21</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">22</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">23</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">printValues</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">24</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Current: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">getValue</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; (parent value: &quot;</span><span class="p">;</span>
<span class="linenos">25</span><span class="w">        </span><span class="c1">// 先将弱指针强化为shared_ptr，再判断是否为空，非空则使用</span>
<span class="linenos">26</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">parent_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getParent</span><span class="p">().</span><span class="n">lock</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">27</span><span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">parent_</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;; &quot;</span><span class="p">;</span>
<span class="linenos">28</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">29</span><span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;None; &quot;</span><span class="p">;</span>
<span class="linenos">30</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">31</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;has &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">getChildren</span><span class="p">().</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; children)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="linenos">32</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">getChildren</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">33</span><span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;* Child value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="linenos">34</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">35</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">36</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">getValue</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="hll"><span class="linenos">37</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">getParent</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</span><span class="hll"><span class="linenos">38</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">getChildren</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">children</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</span><span class="linenos">39</span>
<span class="linenos">40</span><span class="k">private</span><span class="o">:</span>
<span class="linenos">41</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="linenos">42</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span>
<span class="linenos">43</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">children</span><span class="p">;</span>
<span class="linenos">44</span><span class="p">};</span>
<span class="linenos">45</span>
<span class="linenos">46</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">47</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="linenos">48</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">child1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">101</span><span class="p">);</span>
<span class="linenos">49</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">child1_wptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="n">child1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 此处仅用于追踪引用计数</span>
<span class="linenos">50</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">child2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">102</span><span class="p">);</span>
<span class="linenos">51</span><span class="w">    </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">child1</span><span class="p">);</span>
<span class="linenos">52</span><span class="w">    </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">child2</span><span class="p">);</span>
<span class="linenos">53</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">grandchild1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10101</span><span class="p">);</span>
<span class="linenos">54</span><span class="w">    </span><span class="n">child1</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">grandchild1</span><span class="p">);</span>
<span class="linenos">55</span>
<span class="linenos">56</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--- Root ---&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="linenos">57</span><span class="w">    </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">printValues</span><span class="p">();</span>
<span class="linenos">58</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--- Child 1 ---&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="linenos">59</span><span class="w">    </span><span class="n">child1</span><span class="o">-&gt;</span><span class="n">printValues</span><span class="p">();</span>
<span class="linenos">60</span><span class="w">    </span><span class="c1">// 引用计数来自 child1 自身，以及 root 中的 children</span>
<span class="linenos">61</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Use count: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">child1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="linenos">62</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--- Grandchild 1 ---&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="linenos">63</span><span class="w">    </span><span class="n">grandchild1</span><span class="o">-&gt;</span><span class="n">printValues</span><span class="p">();</span>
<span class="linenos">64</span>
<span class="linenos">65</span><span class="w">    </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">removeChild</span><span class="p">(</span><span class="n">child1</span><span class="p">);</span>
<span class="linenos">66</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- Root (After removal) ---&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="linenos">67</span><span class="w">    </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">printValues</span><span class="p">();</span>
<span class="linenos">68</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--- Child 1 (After removal) ---&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="linenos">69</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Use count: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">child1_wptr</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="linenos">70</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--- Grandchild 1 (After removal) ---&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="linenos">71</span><span class="w">    </span><span class="n">grandchild1</span><span class="o">-&gt;</span><span class="n">printValues</span><span class="p">();</span>
<span class="linenos">72</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Use count: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">grandchild1</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
<span class="linenos">73</span>
<span class="linenos">74</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">75</span><span class="p">}</span>
<span class="linenos">76</span><span class="cm">/*</span>
<span class="linenos">77</span><span class="cm">  输出：</span>
<span class="linenos">78</span><span class="cm">  --- Root ---</span>
<span class="linenos">79</span><span class="cm">  Current: 1 (parent value: None; has 2 children)</span>
<span class="linenos">80</span><span class="cm">  * Child value: 101</span>
<span class="linenos">81</span><span class="cm">  * Child value: 102</span>
<span class="linenos">82</span><span class="cm">  --- Child 1 ---</span>
<span class="linenos">83</span><span class="cm">  Current: 101 (parent value: 1; has 1 children)</span>
<span class="linenos">84</span><span class="cm">  * Child value: 10101</span>
<span class="linenos">85</span><span class="cm">  Use count (Node): 2</span>
<span class="linenos">86</span><span class="cm">  Use count (Weak ptr): 2</span>
<span class="linenos">87</span><span class="cm">  --- Grandchild 1 ---</span>
<span class="linenos">88</span><span class="cm">  Current: 10101 (parent value: 101; has 0 children)</span>
<span class="linenos">89</span><span class="cm">  </span>
<span class="linenos">90</span><span class="cm">  --- Root (After removal) ---</span>
<span class="linenos">91</span><span class="cm">  Current: 1 (parent value: None; has 1 children)</span>
<span class="linenos">92</span><span class="cm">  * Child value: 102</span>
<span class="linenos">93</span><span class="cm">  --- Child 1 (After removal) ---</span>
<span class="linenos">94</span><span class="cm">  Use count: 0</span>
<span class="linenos">95</span><span class="cm">  --- Grandchild 1 (After removal) ---</span>
<span class="linenos">96</span><span class="cm">  Current: 10101 (parent value: None; has 0 children)</span>
<span class="linenos">97</span><span class="cm">  Use count: 1</span>
<span class="linenos">98</span><span class="cm">*/</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="TypeConversion.html" class="btn btn-neutral float-left" title="类型转换与溢出*" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="Control.html" class="btn btn-neutral float-right" title="控制流语句" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 wklchris。</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 

<div class="footer">本页面采用 <a href="https://analytics.google.com/">Google Analytics</a> 来记录访问数据. 您可以通过屏蔽来自 www.google-analytics.com 的 JavaScript 来阻止该记录行为.
<script>
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>



</body>
</html>